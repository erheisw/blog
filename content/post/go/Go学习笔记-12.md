---
title: "Go学习笔记 12"
date: 2021-05-08T23:38:45+08:00
draft: true
description: "Go学习笔记-12"
keywords: ["Method","struct"]
tags: ["Go","教程"]
categories: ["技术","笔记"]
---

在编程中占有支配地位的 **OOP** （object-oriented programming），已经被大部分语言所支持，*Go*也不例外。前面介绍了 *struct* ，虽然我们可以用它定义了对象，但现实世界的对象不仅有属性还有行为。上篇详细介绍了 *function*，但它不是某个对象所特有的。我们需要给 *struct* 加一些“function”， 属于 *struct* 的 *function*，我们称之为方法——Method。

<!--more-->

## 1. 方法声明

方法声明类似于函数声明，但需要在函数名前有个额外的参数，这个额外的参数就是拥有方法的某个类型。我们一个具体的例子，从这个简单的例子，我们能看出方法与函数的区别和联系。

```go
package geometry

import "math"

type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
```

上面例子中的额外参数 *p* ，我们称之为方法的接收器。与其它语言不通的事，在*GO*中接收器没有特有的名字关键字，如：*this* 和 *self* 等，接收器参数名字与普通参数名字别无二致。由于我们将会频繁的使用接收器参数，所以为了方便我们通常会尽量命名的比较简短，比较通用的做法就是使用类型名字的第一个字母，但要小写，如：*p*就是Point的首字母的小写形式。

在上面的例子中，函数名与方法名是相同的，这不会冲突。这是因为两者在不同的 *space* 下，函数 *Distance* 是在包级别下的，比如外部调用时：geometry.Distance。然而，方法 *Distance* 是在 *Point* 下，调用时是这样：p.Distance，所以在调用 *Distance* 方法时，我们必须使用 *Point* 类型的变量。因此，每个类型的方法、字段都有自己的命名空间，所以，不同的类型可以有 *Distance* 方法，这并不会冲突。例如下面的例子：

```go
// A Path is a journey connecting the points with straight lines.
type Path []Point

// Distance returns the distance traveled along the path.
func (p Path)Distance()float64{
  sum := 0.0
  for i := range p {
    if i > 0 {
      sum += p[i-1].Distance(p[i])
    }
  }
  return sum
}
```

这个例子中，也存在一个 *Distance* 方法，但与 *Point* 的 *Distance* 方法并不冲突，甚至在 *Path* 的 *Distance* 方法中还可以调用 *Point* 的 *Distance* 方法。

除此之外，还可以发现，*Path* 其实并不是一个 *struct* ，它实际是一个 *slice* ，但我们给了它一个行为（方法）。与其它的 **OO** 语言不同，*GO* 可以给已有的类型添加方法很简单，如：数值、字符串、切片、映射，甚至某些 *函数* 也没问题。当然接口和指针是不行的（注：这里的指针不是某个类型的指针，目前我也不懂，后面章节会介绍）。然我们看个示例吧。

```go
package main

import (
	"fmt"
)

type Weekday int

func (w Weekday) String() string {
	var result string
	switch w {
	case 0:
		result = fmt.Sprintf("The %d day of Week is Sunday.", w)
	case 1:
		result = fmt.Sprintf("The %d day of Week is Monday.", w)
	case 2:
		result = fmt.Sprintf("The %d day of Week is Tuesday.", w)
	case 3:
		result = fmt.Sprintf("The %d day of Week is Wednesday.", w)
	case 4:
		result = fmt.Sprintf("The %d day of Week is Thursday.", w)
	case 5:
		result = fmt.Sprintf("The %d day of Week is Friday.", w)
	case 6:
		result = fmt.Sprintf("The %d day of Week is Saturday.", w)
	default:
		result = fmt.Sprintf("The %d day of Week is invalid.", w)
	}
	return result
}

type FuncA func()

func (f FuncA) Hi() {
	fmt.Println("This FuncA's method")
	f()
}

func Hi() {
	fmt.Println("This is FuncA")
}

func main() {
	w := Weekday(5)
	fmt.Println(w)
	var f FuncA = Hi
	f.Hi()
}
```

*Go* 中，值拷贝无处不在，即使方法的接收器参数也是值拷贝。因此，如果想要改变接收参数的属性就必须使用接收器类型的指针，并且它的使用方式与非指针类型的没有区别。在下面的例子中，我们可以看到指针类型的变量q可以正常调用接收器为非指针的方法，而且非指针类型的变量p同样可以调用接收器为指针的方法。

```go
func (p *Point) ScaleBy (factor float64){
  p.X *= factor
  p.Y *= factor
}
func main(){
  p, q := Point{1,2}, &Point{3,5}
  fmt.Println(p,q,q.Distance(p))
  p.Scale(2.0)
  fmt.Println(p,q,q.Distance(p))
}
```

这里要强调下，如果某个类型有一个方法的接收器参数是指针类型的，那么其它的方法应尽量也统一为指针，这在*Go*中是个约定俗成。上面的例子只是为了展示方法的接收器不同类型的参数。

