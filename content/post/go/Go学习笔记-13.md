---
title: "Go学习笔记 13"
date: 2021-05-15T22:28:45+08:00
draft: true
description: "Go学习笔记-13"
keywords: ["Interface"]
tags: ["Go","教程"]
categories: ["技术","笔记"]
---

接口，是某类行为的抽象集合，它描述了一类或几类对象的共有的行为。所以，接口可以让函数功能不必紧紧绑定在具体的、特定的实现。**Go** 也给我们提供了接口——Interface，与其它语言不同的是 *Go* 中的接口不需要 *struct* 显示的声明实现，它只需要实现某个接口的所有方法，就可以认为该 *struct* 实现了这个接口，这中方式有很多优势。别急，本篇我们就会学习下它——Interface

<!--more-->

## 1. 接口定义

在定义接口之前，我们需要明确接口是什么？在面向对象领域里，接口是这样定义的：**接口描述或定义了对象的行为**。换句话说，接口仅指定了对象应该做什么，至于这个行为的具体细节，由具体的对象来定义。

在 *Go* 语言中，接口可以认为是方法签名的集合。当一个类实现了接口中所有的方法，我们就认为它实现了该接口。

在 *Go* 语言中，使用 *type* 关键字定义接口。如下面代码所示

```go
type Scale interface{
    ScaleBy (factor float64)
}
```

上面示例代码，定义了一个 *Scale* 接口，所以要实现 *Scale* 这个接口，必须实现 *ScaleBy* 这个方法，那怎么实现呢？

## 2. 接口实现

上面我们定义了个接口，要实现这个接口很简单，只要实现它的方法集合就可以。由于它的方法集合只有 *ScaleBy* 一个方法，所以只要实现了这个方法，我们就认为类实现了 *Scale* 接口。

```go
type Point struct{
  X, Y float64
}

func (p *Point)ScaleBy(factor float64){
  p.X *= factor
  p.Y *= factor
}
```

从上面的例子中，可以发现 *Go* 语言中接口实现是隐式的，不像 **Java** 那样显示声明。其实这很有优势，我们可以在包外定义一个接口：它的方法集合恰好包里的类都实现了，这样我们就可以面向接口了，不必指定具体的类型了。

