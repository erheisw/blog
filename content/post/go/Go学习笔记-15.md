---
title: "Go学习笔记 15"
date: 2021-06-08T18:20:05+08:00
draft: true
description: "Go学习笔记-15"
keywords: ["Goroutine","Channel"]
tags: ["Go","教程"]
categories: ["技术","笔记"]
---

[上篇](/post/go/go学习笔记-14/)我们介绍了 *Go* 中的两个明星 *goroutine* 和 *channel* ，本篇我们继续介绍并发中其它的内容，如： *信号量*，*锁或读写锁*，*原子操作*，*延迟加载* 等，这些在如**Java**等其它语言中更常见。下面让我带你看看在 *Go* 中是如何使用这些的。

<!--more-->

## 0 引子

[上篇](post/go/go学习笔记-14/)博客我们介绍了 *goroutine* 中如何使用 *channel* 的，OK，那我们来思考一个常见问题：数据竞态，比如银行账户的余额问题。我们如何在多个 *goroutine* 中使用 *channel* 来解决账户余额的准确状态，如下面示例代码：

```go
var(
	balance int
)
func main(){
  done := make(chan struct{})
  go func(){
    Deposit(200) // A1
    fmt.Println("account balance:",Balance()) // A2
    done<- struct{}{}
  }()
  go func(){
    Deposit(100) //B
    done<-struct{}{}
  }()
  <-done
  <-done
}

func Deposit(amount int){
  balance+=amount
}
func Balance()int{
  return balance
}
```

请思考在上面的代码中，账户余额 *balance* 的值是多少？会出现多少种情况？大概有以下几种情况：

| 200 first | 100 first | 200/100/200 | 200/100/200 |
| :-------: | :-------: | :---------: | ----------- |
|     0     |     0     |      0      | 0           |
|  A1 200   |   B 100   |   A1 200    | A1r 0       |
| A2 "=200" |  A1 300   |    B 300    | B 100       |
|   B 300   | A2 "=300" |  A2 "=300"  | A1w 200     |
|           |           |             | A2 "=200"   |

前三种情况很好理解，我们重点来看最后一种情况。由于在进行 *A1* 操作时是分两步操作的：读取计算和赋值，所以操作 *B* 如果发生在这两个操作中间时，就会导致 *A2* 的结果值是不正确的。所以，这就是我们在多个 *goroutine* 内访问同一个数据会产生的竞态问题。那这怎么解决呢？其实比较简单，大概有两类：

* 避免变量的赋值，即将初始化操作提前至 *goroutine* 之前
* 避免多个 *goroutine* 对同一变量的读写操作，改成单一的 *goroutine* 的访问
* 在多个 *goroutine* 对同一变量读写时，但每次只允许一个进行

我们重点看第二种方法，如果用 *channel* 怎么实现这个目的呢。请思考下再看下面的示例。

```go
var (
  deposits = make(chan int)
  balances = make(chan int)
)

func init(){
  go compute()
}

func compute(){
  var balance =0
  for{
    select{
      case amount := <-deposits:
      		balance+=amount
      case balances<-balance:
    }
  }
}

func main(){
  done := make(chan struct{})
  go func(){
    Deposit(200)
    fmt.Println("account balance:",Balance())
    done<-struct{}{}
  }()
  go func(){
    Deposit(100)
    done<-struct{}{}
  }()
  <-done
  <-done
}

func Deposit(amount int){
  deposits<-amount
}
func Balance()int{
  return <-balances
}
```

在有的时候，我们的逻辑肯能必须是多个 *goroutine* 访问变量，这时该怎么办？这正是上面提到的第三种方式：互斥锁、信号量或原子变量。那我们就开始看看它们是的用法吧。



