---
title: "面试之缓存雪崩、缓存击穿、缓存穿透"
date: 2020-05-28T16:09:18+08:00
description: "面试之缓存方面的问题"
keywords: ["缓存","缓存击穿","缓存雪崩","缓存穿透"]
tags: ["缓存","Redis","Web"]
categories: ["Redis"]
---
年前失业至今，一直再投简历面试，发现机会真的很少，可能是自己水平太菜。最近也面试了几家，决定记录下自己遇到的技术问题，今天主要简单总结下 **Web** 缓存相关的问题。
<!--more-->
## 前言

在我们日常的开发的 **Web** 项目中都会有缓存相关的技术，比如开发语言（Java，C#）自带的 *Cache*类，它可以很轻松的让你将部分数据缓存在服务器上，当然现在主流的互联网开发已经不提倡使用类似的技术，转而推荐使用 **Redis、Memcache** 之类的内存数据库提供缓存功能。今天我们就系统的介绍使用的缓存方案，以及使用时遇到的问题。

首先，缓存引入的原因是什么？我个人理解是因为每次从数据库查询数据特别耗时，对用户体验非常不友好，而且随着产品的用户量增加，系统的QPS肯能会迅速提高，这种情况下数据库会迎来灾难，你的系统可能会宕机。如下图所示：

![None Cache](/media/Redis_cache_issuses.png)

如果我们引入缓存呢，那么每次的查询请求，都会先去查询缓存，如果有缓存的数据，那么直接返回给客户端，如果没有则再去查询数据库，然后放入缓存返回。这样看上去似乎很完美了，但你仔细想象还是可能会出现一些问题。

## 缓存雪崩

缓存雪崩是指，由于缓存层承载的大量请求查询，由于某些原因如：缓存服务器宕机，缓存key大量同时过期等，导致大量请求直接打到数据库层，结果引起数据库服务器宕机。那有什么解决办法呢？

解决方案

1. 保证缓存的高可用，如使用缓存集群，即使个别节点、机器挂掉，依然可以提供服务。如 **Redis Sentinel** 和 **Redis Cluster** 这两个方案

2. 依赖隔离组件为后端服务限流降级

3. 缓存失效后，通过加锁或队列控制读数据库写缓存的县城数量

4. 数据预热，缓存key的过期时间加随机数，使过期时间尽量离散化

## 缓存击穿

大量请求一个 Key 时，此时这个 Key 刚好过期失效了，导致大量请求直接落到数据库上，这就是缓存击穿。我理解时缓存击穿针对是某个热点的 Key。那该怎么解决呢？

解决方法很简单，既然可能会出现多个线程同时去查询数据库的这条数据， 那么我们使用互斥锁，限制只有一个线程去数据库查询，等把查询的结果数据缓存后互斥锁释放，后面的线程进来就直接访问缓存返回了。Redis中使用 **[SETNX](https://redis.io/commands/setnx)** 命令

## 缓存穿透

正常情况下，我们请求查询的数据句都是存在的，那么请求查询一条不存在的数据，换句话说就是缓存和数据库中都不存在这个数据，那结果就是每次的请求查询都会落到数据库上，这种现象我们称之位缓存穿透。那如何解决呢？

1. 缓存空值，我们把这些不存在的key对应的值 null 放入缓存，那么再次查询时，直接返回好了。当然别忘记给这些 key 设置过期时间

2. 使用 **[布隆过滤(BloomFilter)](https://en.wikipedia.org/wiki/Bloom_filter)** ，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap过滤掉，从而避免了对数据库的查询压力。

当然这两个方法可以组合使用，在缓存空值之前加一层 BloomFilter ,这样每次查询先 BloomFilter 查询 key 是否存在，若不存在则直接返回，存在则再走缓存、数据库查询。
